# 数据结构与算法基础

## 数组
* 一维数组计算
  * a[i]的存储地址 a + i * len len为长度
* 二维数组计算 a[m][n]
  * a[i][j] 按行 a + (i * n + j) * len n为每行存最大个数
  * a[i][j] 按列 a + (j * m + i) * len m为每列存最大个数
  * a[0] 是起始地址，具体元素从a[1]开始

## 稀疏矩阵
* 带入计算
* 注意题目从M[1..m]还是具体的哪一个，算法不同

## 线性表
* 顺序表：内存连续空间，插入删除不方便
* 链表
  * 单链表：头节点指向第一个元素,第一个指向第二个
  * 循环链表：把尾元素节点指向头节点
  * 双向链表：指针双向  
* 链表基本操作：
  * 单链表删除节点 : p->next = q->next
  * 单链表插入节点 : s->next = p->next ; p-next = s
  * 双向链表删除节点 :
  * 双向链表插入节点 : 
* 单链表:引入头节点可以使所有的节点操作一致

> 常在链表末尾插入删除尾结点结点时，单向链表复杂度为O(n)
> 循环队列
>  求队头元素的指针的计算公式为：(rear-len+1+M)%M。
>  求队列中元素个数公式为：(rear-fear+M)%M。其中fear表示队列的对头指针。
>  要确认队尾指针指向的是队尾元素还是下一个元素
> 链式存储不需要移动元素，都是移动指针
> 优先队列具有最高级先出的行为特性，所以一般采用二叉堆数据结构实现，时间复杂度同

## 顺序存储与链式存储对比
| 性能类别 | 具体项目 | 顺序存储                               | 链式存储                                  |
| -------- | -------- | -------------------------------------- | ----------------------------------------- |
| 空间性能 | 存储密度 | =1 更优                                | <1                                        |
| ^        | 容量分配 | 事先确定                               | 动态改变,更优                             |
| 时间性能 | 查找运算 | $O(\frac n 2)$                         | $O(\frac n 2)$                            |
| ^        | 读运算   | $O(1)$更优                             | $O(\frac {n+1} 2)$最好情况为1,最差情况为n |
| ^        | 插入运算 | $O(\frac n 2)$ 最好情况为0,最差情况为n | $O(1)$ 更优                               |
| ^        | 删除运算 | $O(\frac {n+1} 2)$                     | $O(1)$ 更优                               |

## 队列与栈
* 队列：先进先出，入列与出列顺序一致
* 栈：先进后出，出栈顺序有多种

## 广义表
* n各元素组成的有序序列，线性表的推广
* **递归重树** 就是广义表的深度（多少各括号嵌套）
* **长度** 为最外层元素个数
* 取数操作
  * head(s)取表头
  * tail(s)取表尾

## 数与二叉树
* 概念
  * 节点的度
  * 树的度
  * 叶子结点
  * 分支节点
  * 父节点
  * 子节点
  * 兄弟节点
* 满二叉树：叶子结点全满
* 完全二叉树：叶子结点连续（全部左对齐）
* 特性