# 数据结构与算法基础

## 数组与矩阵
* 一维数组计算
  * a[i]的存储地址 **（?）**
* 二维数组计算 
  * a[0] 是 **（?）** ，具体元素从 **（?）** 开始，若a[m][n]
    * a[i][j] 按行 **（?）**
    * a[i][j] 按列 **（?）**
* 稀疏矩阵
  * 带入计算

## 线性表（重点掌握）
* 顺序表：内存 **（?）** 空间， **（?）** 不方便
* 链表：
  * 单链表、 循环链表、 双向链表 各是什么样 **（?）**  
* 链表基本操作：
  * 单链表删、插入 **（?）**
  * 双向链表删除、插入 **（?）**
* 单链表:引入头节点可以 **（?）**

> 常在链表末尾插入删除尾结点结点时，单向链表复杂度为O(n)
> * 循环队列
>   * 求队头元素的指针的计算公式为：(rear-len+1+M)%M。
>   * 求队列中元素个数公式为：(rear-fear+M)%M。其中fear表示队列的对头指针。
>   * 根据队尾指针指向的是队尾元素还是下一个元素有所区别，可以具体在题目中带入计算，去摸是必须的。
> 
> 链式存储不需要移动元素，都是移动指针
> 优先队列具有最高级先出的行为特性，所以一般采用二叉 **堆** 数据结构实现，时间复杂度同同

* 顺序存储与链式存储对比

| 性能类别 | 具体项目 | 顺序存储                               | 链式存储                                  |
| -------- | -------- | -------------------------------------- | ----------------------------------------- |
| 空间性能 | 存储密度 | =1 更优                                | <1                                        |
| ^        | 容量分配 | 事先确定                               | 动态改变,更优                             |
| 时间性能 | 查找运算 | $O(\frac n 2)$                         | $O(\frac n 2)$                            |
| ^        | 读运算   | $O(1)$更优                             | $O(\frac {n+1} 2)$最好情况为1,最差情况为n |
| ^        | 插入运算 | $O(\frac n 2)$ 最好情况为0,最差情况为n | $O(1)$ 更优                               |
| ^        | 删除运算 | $O(\frac {n+1} 2)$                     | $O(1)$ 更优                               |

* 队列与栈
  * 队列：先进先出，入列与出列顺序一致
  * 栈：先进后出，出栈顺序有多种

## 广义表
* n各元素组成的有序序列，线性表的推广
* **递归重树** 就是广义表的深度（多少各括号嵌套）
* **长度** 为最外层元素个数
* 取数操作
  * head(s)取表头
  * tail(s)取表尾

## 数与二叉树（重点掌握）
### 概念
  * 节点的度、树的度、 叶子结点、分支节点、父节点、子节点、兄弟节点 各个概念 **（?）**
* 满二叉树、完全二叉树 各是 **（?）**
* 特性
  * i层上最多有 **（?）** 个结点
  * 深度为k的二叉树最多有 **（?）** 个结点
  * 对任一二叉树 **（?）** N0是叶子节点数 N2是度为2的节点数
  * 如果对一个有n个结点的完全二叉树结点按层序编号有从 **（?）** 层
* 二叉树遍历
  * 前中后 各是 **（?）**
* 反向构造二叉树
  * **（?）** 为必须的
* 树转二叉树
  * 结点如何相连 **（?）**


> 二叉排序树的查找效率取决于二叉排序树的深度，对于结点个数相同的二叉排序树，平衡二叉树的深度最小，而单枝树的深度是最大的，故效率最差。

### 查找二叉树（二叉排序树）
* 什么样 **（?）**
* 左右与根节点关系 **（?）**
* 插入：若已存在，**（?）**。若树为空，**（?）**。其他情况 **（?）**
* 删除：若为叶子结点 **（?）**。若只有一个叶子节点 **（?）**。若有两个 **（?）** 

### 哈夫曼树（最优二叉树）
* 什么样 **（?）**
* 如何构造 **（?）**
* 树的路径长度、权 各是 **（?）**
* 带权路径长度、树的带权路径长度（树的代价） 计算 **（?）**
* 根据字符频率画树 **（?）**

### 线索二叉树

### 平衡二叉树
* 什么样 **（?）**
* 定义 **（?）**
* 每个结点的平衡度只能为 **（?）**

## 图
* 无向图，有向图 **（?）**
* 完全图：在无向图中 **（?）** ，在有向图中 **（?）**
* 图的存储：
  * 邻接矩阵：有n个点就是nxn的二维表，边为1，其他为0 **（?）** 画图。无向图有对称性，可以只存上三角或下三角
  * 邻接表 **（?）**、一个数组记录所有结点，每个结点可以到哪些结点用链表连接。 **（?）** 画图
* 图的遍历：
  * 深度优先： **（?）** 画图，一个结点试探到底
  * 广度优先： **（?）** 画图，先访问邻接
* 拓扑排序： **（?）** 画图，表达事件先后执行。从无箭头指向结点开始，结点的前驱结点都完成可以开始
* 图的最小生成树： **（?）** 画图，使权值加起来最小，
  * 普里姆算法：时间复杂度 **$O(n^2)$**，n为定点，图稠密是性能更 **高**
  * 克鲁斯卡算法：时间复杂度 **$O(mlgm)$**，m为边
> 树没有环路，有n个结点，边最多为 **n-1**
> 无向图连接矩阵非零元素为 **2E** ，E为边
> **完全图** 适合采用邻接矩阵来存储
> 

## 算法基础与常见算法（重要）
* 有穷性 、确定性、输入、输出、有效性 **（?）** 各自含义

## 时间复杂度与空间复杂度（重要）
* 时间复杂度 **（?）** 、 空间复杂度 **（?）**
* O(n)、$\log_2n$、$n\log_2n$、一般是 **（?）**
* **递推式** $T(n) = aT(\frac n b) + f(n)$ 时间复杂度比较 **$n^{log{\frac a b}}$** 和f(n)中取较大

## 排序与查找（重点）

### 顺序查找
* 基本思想 **（?）**
* 平均查找时间  **$\frac {n+1} 2$** ， 时间复杂度 **O(n)**

### 二分查找
* 基本思想 **（?）**
* 要求：**必须采用顺序存储结构、必须按关键字大小有序排列**
* 优缺：**比较次数少，查找速度快，平均性能好**；缺点：**要求待查表为有序表，且插入删除困难**；适用：**不经常变动而查找频繁的有序列表**
* 比较次数最多 **$log_2n +1$** 次，时间复杂度为 **$log_2 n$**
* 关键字比较序列出现情况判断，**还原的查找二叉树上一个结点只会有一个子节点**
* 比较过程掌握  **（?）**  ，**注意求mid时小了左移，大了右移**

### 散列表
* 基本思想 **（?）**
* 装填因子代表 **哈希表的装满程度**，越大则 **发生冲突的可能性越大**
* 构造哈希函数使应尽量使关键字的所有组成部分起作用。
* 线性探测法 **（?）**，H（Key） = Key mod p，p的值一般会取 **接近于元素个数n但是要小于n的质数**
* 伪随机数法 **（?）**

### 排序
* 稳定排序与不稳定排序 **（?）**
* 内排序与外排序 **（?）**
* 插入类排序、交换类排序、选择排序、归并排序、基数排序 各分类下有 **（?）**

#### 直接插入排序
* 了解过程 **（?）**
* 在 **基本有序** 情况下为最适宜排序算法
* 提示：一个一个插入时候比较

#### 希尔排序
* 了解过程 **（?）**
* 提示：d=n/2 求增量，反复，直到步长为1

#### 直接（简单）选择排序
* 了解过程 **（?）**
* 提示：剩余部分取出最小的一个与剩余第一个交换，反复。

#### 堆排序
* 了解过程 **（?）**
* 小顶堆 **（?）**、大顶堆
* 提示：建堆、取出堆顶元素、重建、反复

#### 冒泡排序
* 了解过程 **（?）**
* 提示：相邻元素比较，把较小的从底部移到顶部
* 与直接插入排序相比：每次冒泡交换多次，直接交换一次

#### 快速排序（分治法）
* 了解过程 **（?）**
* 采用 **分治** 算法设计四线
* 在 **基本有序** 的时候算法时间复杂度是最坏的，此时为 **$O(n^2)$**
相反在越 **无序** 的时候时间复杂度越低，为 **$O(nlogn)$**
* 提示：选一个基准，把记录分两组比这个小的放左边，大的放右边。再在剩余分组里进行排序

#### 归并排序（合并）（分治）
* 了解过程 **（?）**
* 提示：二路合并。将两个或两个以上的子表合并，最终合并成一个

#### 基数排序
* 了解过程 **（?）**
* 提示：根据关键字排序

#### 总结

| 方式                 | 时间复杂度平均 | 最坏          | 辅助存储     | 稳定   |
| -------------------- | -------------- | ------------- | ------------ | ------ |
| 直接插入排序         | $O(n^2)$       | $O(n^2)$      | $O(1)$       | 稳定   |
| 希尔排序             | $O(n^{1.3})$   | $O(n^2)$      | $O(1)$       | 不稳定 |
| 直接（简单）选择排序 | $O(n^2)$       | $O(n^2)$      | $O(1)$       | 不稳定 |
| 堆排序               | $O(n\log_2n)$  | $O(n\log_2n)$ | $O(1)$       | 不稳定 |
| 冒泡排序             | $O(n^2)$       | $O(n^2)$      | $O(1)$       | 稳定   |
| 快速排序             | $O(n\log_2n)$  | $O(n^2)$      | $O(\log_2n)$ | 不稳定 |
| 归并排序             | $O(n\log_2n)$  | $O(n\log_2n)$ | $O(n)$       | 稳定   |
| 基数排序             | $O(d(r+n))$    | $O(d(r+n))$   | $O(r+n)$     | 稳定   |

## 算法设计思想

* 分治法：的设计思想是将一个难以直接解决的大问题分解成一些规模较少的相同问题以便各个击破，分而治之。
* 动态规划法：与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是独立的。若用分治法来解这类问题，则相同的子问题会被求解多次，以至于最后解决原问题需要耗费指数级时间。
* 贪心法：经常用于解决最优化问题，但他的最优往往是从局部最优来考虑的，每一步都选最优的方案，但这种方案不一定能得到整体上的最优解。
* 回溯法：是一种既带有系统性又带有跳跃性的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根节点出发搜索解空间树。
