#

## 软件开发模型

* 瀑布模型：需求明确
* V模型：注重测试
* 喷泉模型：面向对象，交替进行
* 原形模型：适合需求不明确
* 演化模型：在原型上演化，分为精化、抛弃
* 螺旋模型：迭代，加入风险分析
* 统一过程（UP）：用例驱动，以架构为中心，迭代和增量
  * 初始/初起：
    * 确定项目边界范围
    * **识别系统关键用例**
    * 展示系统候选架构
    * 估计项目费用、时间
    * 评估项目风险
  * 精化/细化：
    * 分析系统问题领域
    * 建立软件架构基础
    * 淘汰最高风险要素
  * 构建：
    * 开发剩余模块
    * 构建组装与。。？
    * 产生适当平台上的集成产物
  * 交付：
    * beta测试
    * 制作发布版本
    * 用户文档定稿
    * 确认新系统
    * 培训、调整产品
* 敏捷方法：
  * 四大价值观：沟通、简单、反馈、勇气
  * 五大原则：快速反馈、简单性假设、逐步修改、提倡更改、优质工作
  * **基本原则**：短平快会议、小型版本发布、合作为重、客户直接参与、自动化测试、适应性计划调整、结对编程、测试驱动开发、持续集成、重构
  * **十二大最佳实践**：计划游戏、**结对编程**、小型发布、集体代码所有制、隐喻、持续集成、简单设计、每周工作40小时、测试先行、现场客户、重构、编码标准
  * 几个方法：
    * 极限编程（XP）：费用控制严格
    * 水晶方法：不同类型的项目需要不同的方法、用最少的纪律约束仍能成功
    * 开放式源码：程序开发人员在地域上分布很广
    * 并列争求法（SCRUM）：**迭代**的增量化过程
    * 特性驱动开发（FDD）：是一个模型驱动的快速迭代开发过程，它强调的是简化、实用、 易于被开发团队接受，适用于需求经常变动的项目。
    * 自适应软件开发（ASD）：

* 角色、活动、工件：

## 软件开发方法：

### 结构化开发方法
  * 结构化开发方法：瀑布模型，V模型
    * 用户至上
    * 严格区分工作阶段，每个阶段有任务和结果
    * 强调系统开发过程的整体性和全局性
    * 系统开发过程工程化，文档资料标准化
    * 自顶向下，逐步分解（求精）

### 原型法
  * 需求不明确
  * 演化式模型，抛弃型模型

### 面向对象方法
  * 螺旋模型，喷泉模型
  * 更好的复用性
  * 关键在于建立一个全面，合理，统一的模型
  * 分析，设计，实现三个阶段不明确

### 面向服务方法
  * 抽象级别：操作，服务，业务流程
  * 三个层次：基础设计层，应用结构层，业务组织层
  * 建模：服务发现，服务规约，服务实现

## 需求分析
* 分析做什么

| 需求的任务 | 需求的过程       | 需求分类   | 应用工具    |
| ---------- | ---------------- | ---------- | ----------- |
| /          | 问题识别         | 功能需求   | 数据流图DFD |
| ^          | 分析与综合       | 分功能需求 | 数据字典DD  |
| ^          | 编制需求分析文档 | 设计约束   | 判定表      |
| ^          | 需求分析与评审   | ^          | 判定树      |

## 软件设计
* 做什么，怎么做
* 概要设计：把系统按功能分成若干模块，确定模块功能，模块联系，数据库
* 详细设计：对模块详细设计，数据结构，物理数据库，代码，IO格式，设计说明书，界面，评审
* 模块设计原则：高内聚低耦合
  * 内聚：（从高到底）
    * 功能内聚：完成一个单一功能，各个部分协同工作，缺一不可。
    * 顺序内聚：处理元素相关，而且必须顺序执行。
    * 通信内聚：所有处理元素集中在一个数据结构的区域上。
    * 过程内聚：处理元素相关，而且必须按特定的次序执行。
    * 瞬时（实践）内聚：所包含的任务必须在同一时间间隔内执行（如初始化模块）。
    * 逻辑内聚：完成逻辑上相关的一组任务。
    * 偶然内聚：完成一组没有关系或松散关系的任务。
  * 耦合：

## 软件测试
  * 动态测试：黑盒测试、白盒测试、灰盒测试
    * 黑盒测试：
      * 等价类划分：
      * 边界值分析：
      * 错误推测：因果图
    * 白盒测试发：
      * 语句覆盖：
      * 判定覆盖：
      * 条件覆盖：
      * 条件判定覆盖：
      * 路径覆盖：
  * 静态测试（手工）：桌前检查、代码审查、代码走查

 V模型

| V模型    |          |                                              |
| -------- | -------- | -------------------------------------------- |
| 需求分析 | 验收测试 | α测试，β测试，有效性测试，审查               |
| 概要设计 | 系统测试 | 非功能测试，恢复，安全，性能，可靠性         |
| 详细设计 | 集成测试 | 模块间的接口和通信                           |
| 编码     | 单元测试 | 魔窟啊接口，局部数据结构，边界条件，错误处理 |

* 回归测试：修改bug后是否引起新的bug
* 负载测试：不同负载下的系统性能
* 压力测试：系统极限值

## McCabe 复杂度（环路复杂度，独立路径）
* V（a）= m - n + 2 ； m为有向弧数，n为结点数
* 画有向图时，流程交汇点也是一个节点
* 代码 -> 有向图
  * 定义变量 -> 一个结点 （一个，多个都转一个）
  * if else -> 一个结点
  * if 之后的代码块 -> 一个结点
  * return -> 连接所有结点






白盒测试是根据（程序的内部结构和逻辑来）设计测试用例

软件配置管理活动，主要（包括变更标识、变更控制和版本控制）。

软件复杂性度量参数包括（规模、难度、 结构、智能度（算法难易））

高质量的文档应具有（针对性、精确性和完整性等特性）

功能性：是指与功能及其指定的性质有关的一组软件质量；
可靠性：是指衡量在规定的一段时间内和规定条件下维护性能水平的一组软件质量；
可维护性：是指与软件维护的难易程度相关的一组软件属性；
易使用性：是指与使用难易程度及规定或隐含用户对使用方式所做的评价相关的属性。



改正性维护：在软件交付使用后，必然会有一部分隐藏的错误被带到运行阶段来。这些隐藏下来的错误在某些特定的使用环境下就会暴露出来。为了纠正这些错误而对软件进行的维护工作就是改正性维护。
适应性维护：随着计算机的飞速发展，外部环境(新的硬、软件配置)或数据环境(数据库、数据格式、数据输入∕输出方式、数据存储介质)或应用环境可能发生变化，为了使软件适应这种变化，而去修改软件的过程就叫做适应性维护。
完善性维护：在软件的使用过程中，用户往往会对软件提出新的功能与性能要求。为了满足这些要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。这种情况下进行的维护活动叫做完善性维护。
预防性维护：为了提高软件的可维护性、可靠性等而提出的一种维护类型，它为以后进一步改进软件打下良好基础。通常，预防性维护定义为：“把今天的方法学用于昨天的系统以满足明天的需要”。也就是说，采用先进的软件工程方法对需要维护的软件或软件中的某一部分(重新)进行设计、编制和测试。

软件需求中对软件产品的相应时间，吞吐量，价格等属性的要求都属于非功能性需求。

测试用例要包括欲测试的功能、应输入的数据和预期的输出结果。测试用例应覆盖有效合理输入，也要包含不合理、失效的输入。

模块结构评审时，主要包括以下方面的评审：
1、控制流结构：规定了处理模块与处理模块之间的流程关系。检查处理模块之间的控制转移关系与控制转移形式（调用方式）。
2、数据流结构：规定了数据模块是如何被处理模块进行加工的流程关系。检查处理模块与数据模块之间的对应关系；处理模块与数据模块之间的存取关系，如建立、删除、查询、修改等。
3、模块结构与功能结构之间的对应关系：包括功能结构与控制流结构的对应关系；功能结构与数据流结构的对应关系；每个模块的定义（包括功能、输入与输出数据）。


仓库风格优点包括：
1、解决问题的多方法性
2、具胡可更改性和可维护性
3、有可重用的知识源
4、支持容错性和健壮性
缺点：
1、测试困难：由于黑板模式的系统有中央数据构件来描述系统的体现系统的状态，所以系统的执行没有确定的顺序，其结果的可再现性比较差，难于测试，
2、不能保证有好的求解方案
3、效率低
4、开发成本高
5、缺少对并行机的支持
 
仓库风格包括：数据库系统、黑板系统、超文本系统。
编译器可用多种架构风格实现。


需要开发的是大型软件系统，大型软件系统的需求往往难以在前期确定，所以（瀑布模型）最不适合。

（NS盒图）清楚的表达复杂条件组合与应做的动作之间的对应关系。
扩展：NS盒图是用于取代传统流程图的一种描述方式。NS盒图形象直观，具有良好的可见度。例如循环的范围、条件语句的范围都是一目了然的，所以容易理解设计意图，为编程、复查、选择测试用例、维护都带来了方便。

CMMI
优化级，达到该级的软件公司过程可自发地不断改进，防止同类问题二次出现
四级称为已管理级，达到该级的软件公司已实现过程的定量化
三级为已定义级，即过程实现标准化
二级为可重复级，达到该级的软件公司过程已制度化，有纪律，可重复
一级为初始级，过程无序，进度、预算、功能和质量等方面不可预测


增量模型融合了瀑布模型的基本成分（重复应用）和原型实现的迭代特征，该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”。当使用增量模型时，第1个增量往往是核心的产品，即第1个增量实现了基本的需求，但很多补充的特征还没有发布。客户对每一个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。由于能够在较短的时间内向用户提交一些有用的工作产品，因此能够解决用户的一些急用功能。由于每次只提交用户部分功能，用户有较充分的时间学习和适应新的产品。
对系统的可维护性是一个极大的提高，因为整个系统是由一个个构件集成在一起的，当需求变更时只变更部分部件，而不必影响整个系统。
增量模型存在以下缺陷：
1） 由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。
2） 在开发过程中，需求的变化是不可避免的。增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而使软件过程的控制失去整体性。
3）如果增量包之间存在相交的情况且未很好处理，则必须做全盘系统分析，这种模型将功能细化后分别开发的方法较适应于需求经常改变的软件开发过程。


逆向工程从源代码或目标代码中提取设计信息，通常在原软件生命周期的（软件维护）阶段进行。

（大规模项目）最不适于采用无主程序员组的开发人员组织形式

顶层数据流图描述了（系统的输入与输出）。

喷泉模型主要用于描述面向对象的开发过程。喷泉一词体现了面向对象开发过程的迭代和无间隙特征。迭代意味着模型中的开发活动常常需要多次重复，每次重复都会增加或明确一些目标系统的性质，但却不是对先前工作结果的本质性改动。无间隙是指在开发活动（如分析、设计、编程）之间不存在明显的边界，而是允许各开发活动交叉、迭代地进行。