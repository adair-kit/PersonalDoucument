# 软件工程

## 软件开发模型

* 瀑布模型：需求明确，需求清晰，不适合大型软件
* V模型：注重测试
* 喷泉模型：面向对象，交替进行
* 原形模型：适合需求不明确
* 演化模型：在原型上演化，分为精化、抛弃
* 增量模型：适合需求不明确，可快速构造可运行产品，不利于模块划分
* 螺旋模型：迭代，加入风险分析
* 统一过程（UP）：用例驱动，以架构为中心，迭代和增量
  * 五个核心工作流：需求流、分析流、设计流、实现流、测试流
  * 四个阶段
    * 初始/初起：（生命周期目标）
      * 确定项目边界范围
      * **识别系统关键用例**
      * 展示系统候选架构
      * 估计项目费用、时间
      * 评估项目风险
    * 精化/细化：（生命周期架构）
      * 分析系统问题领域
      * 建立软件架构基础
      * 淘汰最高风险要素
    * 构建：（初始运作功能）
      * 开发剩余模块
      * 构建组装与。。？
      * 产生适当平台上的集成产物
    * 交付：（产品发布）
      * beta测试
      * 制作发布版本
      * 用户文档定稿
      * 确认新系统
      * 培训、调整产品
* 敏捷方法：
  * 四大价值观：沟通、简单、反馈、勇气
  * 五大原则：快速反馈、简单性假设、逐步修改、提倡更改、优质工作
  * **基本原则**：短平快会议、小型版本发布、合作为重、客户直接参与、自动化测试、适应性计划调整、结对编程、测试驱动开发、持续集成、重构
  * **十二大最佳实践**：计划游戏、**结对编程**、小型发布、集体代码所有制、隐喻、持续集成、简单设计、每周工作40小时、测试先行、现场客户、重构、编码标准
  * 几个方法：
    * 极限编程（XP）：费用控制严格
    * 水晶方法：不同类型的项目需要不同的方法、不同策略、用最少的纪律约束仍能成功
    * 开放式源码：程序开发人员在地域上分布很广
    * 并列争求法（SCRUM）：**迭代**的增量化过程
    * 特性驱动开发（FDD）：是一个模型驱动的快速迭代开发过程，它强调的是简化、实用、 易于被开发团队接受，适用于需求经常变动的项目。
    * 自适应软件开发（ASD）：

* 角色、活动、工件：

## 软件开发方法：

### 结构化
  * 结构化开发方法：瀑布模型，V模型
    * 用户至上
    * 严格区分工作阶段，每个阶段有任务和结果
    * 强调系统开发过程的整体性和全局性
    * 系统开发过程工程化，文档资料标准化
    * 自顶向下，逐步分解（求精）

### 原型化
  * 需求不明确
  * 演化式模型，抛弃型模型

### 面向对象方法
  * 喷泉模型
  * 更好的复用性
  * 关键在于建立一个全面，合理，统一的模型
  * 分析，设计，实现三个阶段不明确
  * 更适用于大规模，特别复杂的项目

### 面向服务方法
  * 抽象级别：操作，服务，业务流程
  * 三个层次：基础设计层，应用结构层，业务组织层
  * 建模：服务发现，服务规约，服务实现

## 需求分析
* 分析做什么

| 需求的任务 | 需求的过程       | 需求分类   | 应用工具    |
| ---------- | ---------------- | ---------- | ----------- |
| /          | 问题识别         | 功能需求   | 数据流图DFD |
| ^          | 分析与综合       | 非功能需求 | 数据字典DD  |
| ^          | 编制需求分析文档 | 设计约束   | 判定表      |
| ^          | 需求分析与评审   | ^          | 判定树      |

* 软件需求中对软件产品的（**响应时间，吞吐量，价格**）等属性的要求都属于非功能性需求。
* 顶层数据流图描述了（**系统的输入与输出**）。
* （**数据流图**）是结构化分析模型需求分析阶段得到的结果，描述了系统的功能，在进行接口设计时，应以它为依据。
* 将每个用户的数据和其他用户的数据隔离开，是考虑了软件的（**功能性**）质量特性。
  * 功能性：是指与功能及其指定的性质有关的一组软件质量；
  * 可靠性：是指衡量在规定的一段时间内和规定条件下维护性能水平的一组软件质量；
  * 可维护性：是指与软件维护的难易程度相关的一组软件属性；
  * 易使用性：是指与使用难易程度及规定或隐含用户对使用方式所做的评价相关的属性。
* 数据流图主要由 **实体、数据存储、处理过程和数据流** 
* 数据流图的平衡原则：必须要保持父图与子图平衡，且每个加工必须要有输入数据流和输出数据流，而每条数据流都至少有一端是加工，而且还要能保持数据守恒（即相关数据流经过加工后得到相应的输出数据流）
* 数据流图的设计原则：
  * 数据守恒原则：对任何一个加工来说，其所有输出数据流中的数据必须能从该加工的输入数据流中直接获得，或者说是通过该加工能产生的数据。
  * 守恒加工原则：对同一个加工来说，输入与输出的名字必须不相同，即使它们的组成成分相同，即使它们的组成成分相同。
  * 对于每个加工，必须既有输入数据流，又有输出数据流
  * 外部实体与外部实体之间不存在数据流
  * 外部实体与外部存储之间不存在数据流
  * 数据存储与数据存储之间不存在数据流
  * 父图与子图的平衡原则
  * 数据流与加工有关，且必须经过加工

## 软件设计
* 做什么，怎么做
* 概要设计：划分模块，模块的层次结构，模块调用关系，每个模块功能，系统的总体数据结构和数据库结构 产出软件结构图
* 详细设计：对模块详细设计，数据结构，物理数据库，代码，IO格式，设计说明书，界面，评审 产出流程图、N-S图，PAD，伪代码
  * 结构化设计方法中，概要设计阶段进行软件体系结构的设计、数据设计和接口设计；详细设计阶段进行数据结构和算法的设计。
  * 面对对象设计方法中，概要设计阶段进行体系结构设计、初步的类设计/数据设计、结构设计；详细设计阶段进行构件设计。
* 模块设计原则：高内聚低耦合
  * 内聚：（从高到底）
    * 功能内聚：完成一个单一功能，各个部分协同工作，缺一不可。
    * **顺序内聚**：处理元素相关，而且必须顺序执行。
    * 通信内聚：所有处理元素 **集中在一个数据结构**的区域上。
    * **过程内聚**：处理元素相关，而且必须按特定的次序执行。
    * 瞬时（实践）内聚：所包含的任务必须在同一时间间隔内执行（如初始化模块）。
    * 逻辑内聚：完成逻辑上相关的一组任务。通过 **参数确定**该模块完成哪一个功能
    * 偶然（巧合）内聚：完成一组 **没有关系或松散关系**的任务。
  * 耦合：（低到高）
    * 非直接耦合：两个模块没有直接关系，他们之间的联系完全通过主模块调用实现
    * 数据耦合：模块间传递的时简单变量（不是控制参数、公共数据结构和外部变量），相当于高级语言的值传递
    * 标记耦合：一组模块通过 **数据结构/参数表** 传递记录信息，如高级语言数组名、记录名、文件名等这些名字即为标记
    * 控制耦合：一个模块通过传递 **控制变量（开关，标志）**等控制信息，明显的控制选择另一模块的功能
    * 外部耦合：一组模块都访问同 **同一全局简单变量而不是同一全局数据结构**，而且不是通过参数表传递该全局变量的信息
    * 公共耦合：一组模块都访问 **同一个公共数据环境**，。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区。
    * 内容耦合：一个模块真接访问另一个模块的内部数据;一个模块不通过正常入口转到另一一个模块的内部;两个模块有一一部分程序代码重叠;一个模块有多个入口

>**扩展**
>* 仓库风格
>   * 测试困难
>   * 仓库风格包括：数据库系统、黑板系统、超文本系统。
>   * 编译器可用多种架构风格实现。
>* 传入、传出、变换模块
>   * 传入：从下属模块取得数据，经过处理再将其传送给上级模块
>   * 传出：从上级模块取得数据，经过处理再将其传送给下级模块
>   * 变换：从上级模块取得数据，进行特定的处理，转换成其他形式，再传送给上级模块
>* 软件复杂性：规模，难度，结构，智能度（算法的难易程度）
>* 可移植性包括：适应性、易安装性、共存性和易替换性

## 软件测试
* 原则
  * 尽早、不断的进行测试
  * 程序员避免测试自己设计的程序
  * 既要选择有效、合理的数据，也要选择无效、不合理的数据
  * 修改后应进行回归测试
  * 尚未发现的错误数量与该程序已发现错 误数成正比
* 分类
  * 动态测试：黑盒测试、白盒测试、灰盒测试
    * 黑盒测试：不知道程序设计结构
      * 等价类划分：
      * 边界值分析：
      * 错误推测：因果图
    * 白盒测试：**依据程序的内部逻辑**
      * 语句覆盖：
      * 判定覆盖：
      * 条件覆盖：
      * 条件判定覆盖：
      * 路径覆盖：
  * 静态测试（手工）：桌前检查、代码审查、代码走查

 V模型

| V模型    |          |                                              |
| -------- | -------- | -------------------------------------------- |
| 需求分析 | 验收测试 | α测试，β测试，有效性测试，审查               |
| 概要设计 | 系统测试 | 非功能测试，恢复，安全，性能，可靠性         |
| 详细设计 | 集成测试 | 模块间的接口和通信                           |
| 编码     | 单元测试 | 模块接口，局部数据结构，边界条件，错误处理 |

* 回归测试：修改bug后是否引起新的bug
* 负载测试：不同负载下的系统性能
* 压力测试：系统极限值

>**扩展**
>* 测试
>   * 自顶向下
>   * 自下向上
>   * 三明治，结合上述两种

>* 自顶向下集成
>   * **优点**：较早地验证了主要控制和判断点；按深度优先可以首先实现和验证一个完整的软件功能；功能较早证实，带来信心；只需一个驱动，减少驱动器开发的费用；支持故障隔离。
>   * **缺点**：柱的开发量大；底层验证被推迟；底层组件测试不充分。
>   * **适应于** 产品控制结构比较清晰和稳定；高层接口变化较小；底层接口未定义或经常可能被修改；产口控制组件具有较大的技术风险，需要尽早被验证；希望尽早能看到产品的系统功能行为。
>* 自底向上集成
>   * **优点**：对底层组件行为较早验证；工作最初可以并行集成，比自顶向下效率高；减少了桩的工作量；支持故障隔离。
>   * **缺点**：驱动的开发工作量大；对高层的验证被推迟，设计上的错误不能被及时发现。
>   * **适应于** 底层接口比较稳定；高层接口变化比较频繁；底层组件较早被完成。
>* 在单元测试开始时，应该对通过所有被测模块的数据流进行测试。
>   * 输入参数是否与形式参数是否一致。
>   * 调用模块的实参与被调用模块形参是否一致。
>   * 全局变量在各模块中的定义和用法是否一致
>   * 外部输入、输出等等。



## McCabe 复杂度（环路复杂度，独立路径）
* V（a）= m - n + 2 ； m为有向弧数，n为结点数
* 画有向图时，流程交汇点也是一个节点
* 代码 -> 有向图
  * 定义变量 -> 一个结点 （一个，多个都转一个）
  * if else -> 一个结点
  * if 之后的代码块 -> 一个结点
  * return -> 连接所有结点

## 软件维护
* 可维护性因素决定：可理解性、可修改性、可测试性
* 软件维护类型
  * 改正性维护：修改错误。
  * 适应性维护：适应外部环境、数据环境、应用环境，为了使软件适应这种变化去修改软件
  * 预防性维护：提高软件的可维护性，可靠性等
  * 完善性维护：扩充/新增功能和改善性能

## 软件工程国家标准 - 软件文档管理指南 - 按阅读对象分类
* 开发文档
  * 可行性研究和项目任务书
  * 需求规格说明
  * 功能设计说明
  * 设计规格说明
  * 开发计划
  * 软件集成和测试设计
  * 质量保证计划、标准、进度
  * 安全和测试信息
* 产品文档
  * 培训手册
  * 参考手册和用户指南
  * 软件支持手册
  * 产品手册和信息广告
* 管理文档
  * 开发过程的每个阶段的进入和进度变更记录
  * 软件变更情况的记录
  * 相对于开发的判定记录
  * 职责定义

## 软件质量保证
* 功能性： 适合性、准确性、互操作性、安全保密性
* 可靠性：成熟性、容错性、易恢复性
* 易用性：易理解性、易学性、易操作性、吸引性
* 效率：时间特性、资源利用性
* 维护性：易分析性、易改变性、稳定性、易测试性
* 可移植性：适应性、易安装性、共存性、易替换性

## CMMI 软件成熟度模型
* 初始级：杂乱。过程无序，进度、预算、功能和质量等方面不可预测
* 可管理级：纪律化的过程。建立了基本的项目管理过程来跟踪费用、进度和功能特性
* 已定义级：标准一致的过程。已将软件管理和工程两方面的过程文档化、**标准化**，并综合成该组织的标准软件过程
* 量化（管理）级：可预测的过程。分析对软件过程和产品质量的详细度量数据，对软件过程和产品质量都有 **定量** 的理解与控制。
* 优化（管理）级：不断改进的过程。过程的量化反馈和先进的新思想、新技术促使过程持续 **不断改进**。

## 一些题目及其他
* 高质量的文档应具有（针对性、精确性和完整性等特性）


### 软件设计
* （逻辑）内聚完成逻辑上相似的功能，通过参数确定该模块完成哪一个功能
* 一个模块的作用范围应在其控制范围之内，且判定所在的模块应在其影响的模块在层次上尽量靠近。如果再设计过程中，发现模块作用范围不在其控制范围之内，可以用（上移判点）或（下移受判断影响的模块）将它下移到判断所在模块的控制范围内”的方法加以改进。
* 系统模块结构设计的任务是确定划分后的子系统的模块结构，并画出模块结构图，这个过程中必须考虑这样几个问题：（每个子系统如何划分成若干个模块）、（如何确定子系统之间、模块之间传送的数据及其调用关系）、（如何评价并改进模块结构的质量）、（如何从数据流图导出模块结构图)。
* （NS盒）图是用于取代传统流程图的一种描述方式，够清楚地表示复杂的条件组合与应做的动作之间的对应关系。
* 数据结构跟算法是系统的基础，是（过程设计）确定确定的任务
* 某模块中有两个处理A和B，分别对数据结构X写数据和读数据，则该模块的内聚类型为（通信）内聚。
* 模块划分遵循原则：模块大小要适中、扇入扇出要合理、深度和宽度适当。
* 宽道过滤器不支持（批处理和并发操作）。

### 软件测试
* 测试用例要包括（欲测试的功能、应输入的数据和预期的输出结果）。
* 测试用例应覆盖（有效合理输入，也要包含不合理、失效的输入）。
* 测试的目标是从（需求分析阶段）阶段开始的
* 模块之间传递参数的错误，在（集成测试）中最可能测试出来

### 软件维护
* 基于构件的软件开发，主要强调在构建软件系统时复用已有的软件“构件”，在检索到可以使用的构件后，需要针对新系统的需求对构件进行合格性检验、（适应性修改），然后集成到新系统中。
* 在软件维护阶段，为软件的运行增加监控设施属于（适应性维护）维护。
* 逆向工程从源代码或目标代码中提取设计信息，通常在原软件生命周期的（软件维护）阶段进行。


### 软件质量保证及配置
* 软件配置管理活动，主要（包括变更标识、变更控制和版本控制）。
* 配置数据库一般包括（开发库、受控库和产品库）。
* 设计质量评审的内容主要有：软件需求规格说明、软件可靠性、软件是否具有可修改性、可扩充性、可互换性、可移植性、可测试行和可重用性及软性性能的实现情况等。
* McCall软件质量模型从软件产品的（运行、修正和转移）三个方面确定了11个质量特性，其中
  * 运行方面包含了（正确性、可靠性、效率、完整性、使用性）这些质量特性。
  * 修正方面包含了（维护性、测试性、灵活性这）3个质量特性。
  * 转移方面包含了（维护性移植性、复用性、共运行性这）3个质量特性。
* 模块结构评审时，主要包括以下方面的评审：（控制流结构、数据流结构、模块结构与功能结构之间的对应关系）

### CMMI 软件成熟度模型
* CMMI是一种过程改进模型，它不仅支持（阶段性）过程改进，而且还支持（连续性）过程改进。