# 软件工程

## 软件开发模型

* 瀑布模型：需求明确，需求清晰，不适合大型软件
* V模型：注重测试
* 喷泉模型：面向对象，交替进行
* 原形模型：适合需求不明确
* 演化模型：在原型上演化，分为精化、抛弃
* 增量模型：适合需求不明确，可快速构造可运行产品，不利于模块划分
* 螺旋模型：迭代，加入风险分析
* 统一过程（UP）：用例驱动，以架构为中心，迭代和增量
  * 五个核心工作流：需求刘、分析流、设计流、实现流、测试流
  * 四个阶段
    * 初始/初起：（生命周期目标）
      * 确定项目边界范围
      * **识别系统关键用例**
      * 展示系统候选架构
      * 估计项目费用、时间
      * 评估项目风险
    * 精化/细化：（生命周期架构）
      * 分析系统问题领域
      * 建立软件架构基础
      * 淘汰最高风险要素
    * 构建：（初始运作功能）
      * 开发剩余模块
      * 构建组装与。。？
      * 产生适当平台上的集成产物
    * 交付：（产品发布）
      * beta测试
      * 制作发布版本
      * 用户文档定稿
      * 确认新系统
      * 培训、调整产品
* 敏捷方法：
  * 四大价值观：沟通、简单、反馈、勇气
  * 五大原则：快速反馈、简单性假设、逐步修改、提倡更改、优质工作
  * **基本原则**：短平快会议、小型版本发布、合作为重、客户直接参与、自动化测试、适应性计划调整、结对编程、测试驱动开发、持续集成、重构
  * **十二大最佳实践**：计划游戏、**结对编程**、小型发布、集体代码所有制、隐喻、持续集成、简单设计、每周工作40小时、测试先行、现场客户、重构、编码标准
  * 几个方法：
    * 极限编程（XP）：费用控制严格
    * 水晶方法：不同类型的项目需要不同的方法、不同策略、用最少的纪律约束仍能成功
    * 开放式源码：程序开发人员在地域上分布很广
    * 并列争求法（SCRUM）：**迭代**的增量化过程
    * 特性驱动开发（FDD）：是一个模型驱动的快速迭代开发过程，它强调的是简化、实用、 易于被开发团队接受，适用于需求经常变动的项目。
    * 自适应软件开发（ASD）：

* 角色、活动、工件：

## 软件开发方法：

### 结构化
  * 结构化开发方法：瀑布模型，V模型
    * 用户至上
    * 严格区分工作阶段，每个阶段有任务和结果
    * 强调系统开发过程的整体性和全局性
    * 系统开发过程工程化，文档资料标准化
    * 自顶向下，逐步分解（求精）

### 原型化
  * 需求不明确
  * 演化式模型，抛弃型模型

### 面向对象方法
  * 喷泉模型
  * 更好的复用性
  * 关键在于建立一个全面，合理，统一的模型
  * 分析，设计，实现三个阶段不明确
  * 更适用于大规模，特别复杂的项目

### 面向服务方法
  * 抽象级别：操作，服务，业务流程
  * 三个层次：基础设计层，应用结构层，业务组织层
  * 建模：服务发现，服务规约，服务实现

## 需求分析
* 分析做什么

| 需求的任务 | 需求的过程       | 需求分类   | 应用工具    |
| ---------- | ---------------- | ---------- | ----------- |
| /          | 问题识别         | 功能需求   | 数据流图DFD |
| ^          | 分析与综合       | 非功能需求 | 数据字典DD  |
| ^          | 编制需求分析文档 | 设计约束   | 判定表      |
| ^          | 需求分析与评审   | ^          | 判定树      |

* 软件需求中对软件产品的（相应时间，吞吐量，价格）等属性的要求都属于非功能性需求。
* 顶层数据流图描述了（**系统的输入与输出**）。
* （数据流图）是结构化分析模型需求分析阶段得到的结果，描述了系统的功能，在进行接口设计时，应以它为依据。
* 将每个用户的数据和其他用户的数据隔离开，是考虑了软件的（功能性）质量特性。
  * 功能性：是指与功能及其指定的性质有关的一组软件质量；
  * 可靠性：是指衡量在规定的一段时间内和规定条件下维护性能水平的一组软件质量；
  * 可维护性：是指与软件维护的难易程度相关的一组软件属性；
  * 易使用性：是指与使用难易程度及规定或隐含用户对使用方式所做的评价相关的属性。
* 数据流图主要由 **实体、数据存储、处理过程和数据流** 
* 数据流图的平衡原则：必须要保持父图与子图平衡，且每个加工必须要有输入数据流和输出数据流，而每条数据流都至少有一端是加工，而且还要能保持数据守恒（即相关数据流经过加工后得到相应的输出数据流）
* 数据流图的设计原则：
  * 数据守恒原则：对任何一个加工来说，其所有输出数据流中的数据必须能从该加工的输入数据流中直接获得，或者说是通过该加工能产生的数据。
  * 守恒加工原则：对同一个加工来说，输入与输出的名字必须不相同，即使它们的组成成分相同，即使它们的组成成分相同。
  * 对于每个加工，必须既有输入数据流，又有输出数据流
  * 外部实体与外部实体之间不存在数据流
  * 外部实体与外部存储之间不存在数据流
  * 数据存储与数据存储之间不存在数据流
  * 父图与子图的平衡原则
  * 数据流与加工有关，且必须经过加工

## 软件设计
* 做什么，怎么做
* 概要设计：把系统按功能分成若干模块，确定模块功能，模块联系，数据库
* 详细设计：对模块详细设计，数据结构，物理数据库，代码，IO格式，设计说明书，界面，评审
* 模块设计原则：高内聚低耦合
  * 内聚：（从高到底）
    * 功能内聚：完成一个单一功能，各个部分协同工作，缺一不可。
    * **顺序内聚**：处理元素相关，而且必须顺序执行。
    * 通信内聚：所有处理元素集中在一个数据结构的区域上。
    * **过程内聚**：处理元素相关，而且必须按特定的次序执行。
    * 瞬时（实践）内聚：所包含的任务必须在同一时间间隔内执行（如初始化模块）。
    * 逻辑内聚：完成逻辑上相关的一组任务。
    * 偶然内聚：完成一组没有关系或松散关系的任务。
  * 耦合：（低到高）
    * 非直接耦合：两个模块之间没有直接关系，它们2间的联系完全是通过主模块的控制和调用来实现的数据耦合  一组模块借助参数表传递简单数据
    * 标记耦合：一组模块通过 **参数**表传递记录信息(数据结构)
    * 控制耦合：模块之间传递的信息中包含用于 **控制模块**内部逻辑的信息
    * 外部耦合：组模块都访问同 **一全局简单变量**，而且不是通过参数表传递该全局变量的信息
    * 公共耦合：多个模块都访问 **同一个公共数据环境**
    * 内容耦合：一个模块真接访问另一个模块的内部数据;一个模块不通过正常入口转到另一一个模块的内部;两个模块有一一部分程序代码重叠;一个模块有多个入口


## 软件测试
* 原则
  * 尽早、不断的进行测试
  * 程序员避免测试自己设计的程序
  * 既要选择有效、合理的数据，也要选择无效、不合理的数据
  * 修改后应进行回归测试
  * 尚未发现的错误数量与该程序已发现错 误数成正比
* 分类
  * 动态测试：黑盒测试、白盒测试、灰盒测试
    * 黑盒测试：不知道程序设计结构
      * 等价类划分：
      * 边界值分析：
      * 错误推测：因果图
    * 白盒测试：知道程序设计结构
      * 语句覆盖：
      * 判定覆盖：
      * 条件覆盖：
      * 条件判定覆盖：
      * 路径覆盖：
  * 静态测试（手工）：桌前检查、代码审查、代码走查

 V模型

| V模型    |          |                                              |
| -------- | -------- | -------------------------------------------- |
| 需求分析 | 验收测试 | α测试，β测试，有效性测试，审查               |
| 概要设计 | 系统测试 | 非功能测试，恢复，安全，性能，可靠性         |
| 详细设计 | 集成测试 | 模块间的接口和通信                           |
| 编码     | 单元测试 | 魔窟啊接口，局部数据结构，边界条件，错误处理 |

* 回归测试：修改bug后是否引起新的bug
* 负载测试：不同负载下的系统性能
* 压力测试：系统极限值

## McCabe 复杂度（环路复杂度，独立路径）
* V（a）= m - n + 2 ； m为有向弧数，n为结点数
* 画有向图时，流程交汇点也是一个节点
* 代码 -> 有向图
  * 定义变量 -> 一个结点 （一个，多个都转一个）
  * if else -> 一个结点
  * if 之后的代码块 -> 一个结点
  * return -> 连接所有结点

## 软件维护
* 可维护性因素决定：可理解性、可修改性、可测试性
* 软件维护类型
  * 改正性维护：修改错误。
  * 适应性维护：适应外部环境、数据环境、应用环境，为了使软件适应这种变化去修改软件
  * 预防性维护：提高软件的可维护性，可靠性等
  * 完善性维护：扩充/新增功能和改善性能

## 软件工程国家标准 - 软件文档管理指南 - 按阅读对象分类
* 开发文档
  * 可行性研究和项目任务书
  * 需求规格说明
  * 功能设计说明
  * 设计规格说明
  * 开发计划
  * 软件集成和测试设计
  * 质量保证计划、标准、进度
  * 安全和测试信息
* 产品文档
  * 培训手册
  * 参考手册和用户指南
  * 软件支持手册
  * 产品手册和信息广告
* 管理文档
  * 开发过程的每个阶段的进入和进度变更记录
  * 软件变更情况的记录
  * 相对于开发的判定记录
  * 职责定义

## 软件质量保证
* 功能性： 适合性、准确性、互操作性、安全保密性
* 可靠性：成熟性、容错性、易恢复性
* 易用性：易理解性、易学性、易操作性、吸引性
* 效率：时间特性、资源利用性
* 维护性：易分析性、易改变性、稳定性、易测试性
* 可移植性：适应性、易安装性、共存性、易替换性

* 可靠性
* 易用性
* 效率
* 维护性
* 可移植性

## CMMI 软件成熟度模型
* 初始级：杂乱。过程无序，进度、预算、功能和质量等方面不可预测
* 可管理级：纪律化的过程。建立了基本的项目管理过程来跟踪费用、进度和功能特性
* 已定义级：标准一致的过程。已将软件管理和工程两方面的过程文档化、**标准化**，并综合成该组织的标准软件过程
* 量化（管理）级：可预测的过程。分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有 **定量** 的理解与控制。
* 优化（管理）级：不断改进的过程。过程的量化反馈和先进的新思想、新技术促使过程持续 **不断改进**。




白盒测试是根据（程序的内部结构和逻辑来）设计测试用例

软件配置管理活动，主要（包括变更标识、变更控制和版本控制）。

软件复杂性度量参数包括（规模、难度、 结构、智能度（算法难易））

高质量的文档应具有（针对性、精确性和完整性等特性）







测试用例要包括欲测试的功能、应输入的数据和预期的输出结果。测试用例应覆盖有效合理输入，也要包含不合理、失效的输入。

模块结构评审时，主要包括以下方面的评审：
1、控制流结构：规定了处理模块与处理模块之间的流程关系。检查处理模块之间的控制转移关系与控制转移形式（调用方式）。
2、数据流结构：规定了数据模块是如何被处理模块进行加工的流程关系。检查处理模块与数据模块之间的对应关系；处理模块与数据模块之间的存取关系，如建立、删除、查询、修改等。
3、模块结构与功能结构之间的对应关系：包括功能结构与控制流结构的对应关系；功能结构与数据流结构的对应关系；每个模块的定义（包括功能、输入与输出数据）。


仓库风格优点包括：
1、解决问题的多方法性
2、具胡可更改性和可维护性
3、有可重用的知识源
4、支持容错性和健壮性
缺点：
1、测试困难：由于黑板模式的系统有中央数据构件来描述系统的体现系统的状态，所以系统的执行没有确定的顺序，其结果的可再现性比较差，难于测试，
2、不能保证有好的求解方案
3、效率低
4、开发成本高
5、缺少对并行机的支持
 
仓库风格包括：数据库系统、黑板系统、超文本系统。
编译器可用多种架构风格实现。


（NS盒图）清楚的表达复杂条件组合与应做的动作之间的对应关系。
扩展：NS盒图是用于取代传统流程图的一种描述方式。NS盒图形象直观，具有良好的可见度。例如循环的范围、条件语句的范围都是一目了然的，所以容易理解设计意图，为编程、复查、选择测试用例、维护都带来了方便。

CMMI



逆向工程从源代码或目标代码中提取设计信息，通常在原软件生命周期的（软件维护）阶段进行。

（大规模项目）最不适于采用无主程序员组的开发人员组织形式



喷泉模型主要用于描述面向对象的开发过程。喷泉一词体现了面向对象开发过程的迭代和无间隙特征。迭代意味着模型中的开发活动常常需要多次重复，每次重复都会增加或明确一些目标系统的性质，但却不是对先前工作结果的本质性改动。无间隙是指在开发活动（如分析、设计、编程）之间不存在明显的边界，而是允许各开发活动交叉、迭代地进行。

软件成本估算比较常用的模型有Putnam模型，功能点模型，COCOMO模型和后续的COCOMO II模型。其中以COCOMO II模型的使用最为广泛，它是cocomo模型的改进，以成本为主要因素，考虑多成本驱动因素。


过程设计（数据结构与算法）、 接口设计、 数据设计、 体系结构设计、


敏捷开发方法中，系统的设计要尽可能早的发布，属于（小型发布）最佳实践

替换原有系统，适合采用（瀑布）开发


面向数据流的设计是以需求分析阶段产生的数据流图为基础，按一定的步骤映射成软件结构，因此又称结构化设计。该方法由美国IBM公司L.Constantine和E.Yourdon等人于1974年提出，与结构化分析(SA)衔接，构成了完整的结构化分析与设计技术，是目前使用最广泛的软件设计方法之一。
各种软件系统，不论DFD如何庞大和复杂，一般可分为变换型和事务型，一个软件系统既可以只有一种数据流类型，也可以是两种数据流烈性。在结构化设计中，可以将数据流映射为软件系统的模块结构，不同类型的数据流有不同的映射方法。

