# 数据结构与算法基础

## 数组与矩阵
* 一维数组计算
  * a[i]的存储地址 **（?）**
* 二维数组计算 
  * a[0] 是 **（?）** ，具体元素从 **（?）** 开始，若a[m][n]
    * a[i][j] 按行 **（?）**
    * a[i][j] 按列 **（?）**
* 稀疏矩阵
  * 带入计算

## 线性表（重点掌握）
* 顺序表：内存 **（?）** 空间， **（?）** 不方便
* 链表：
  * 单链表、 循环链表、 双向链表 各是什么样 **（?）**  
* 链表基本操作：
  * 单链表删、插入 **（?）**
  * 双向链表删除、插入 **（?）**
* 单链表:引入头节点可以 **（?）**

> 常在链表末尾插入删除尾结点结点时，单向链表复杂度为O(n)
> * 循环队列
>   * 求队头元素的指针的计算公式为：(rear-len+1+M)%M。
>   * 求队列中元素个数公式为：(rear-fear+M)%M。其中fear表示队列的对头指针。
>   * 根据队尾指针指向的是队尾元素还是下一个元素有所区别，可以具体在题目中带入计算，取摸是必须的。
> 
> 链式存储不需要移动元素，都是移动指针
> 优先队列具有最高级先出的行为特性，所以一般采用二叉 **（?）** 数据结构实现，时间复杂度 **（?）**

* 顺序存储与链式存储对比

| 性能类别 | 具体项目 | 顺序存储                                  | 链式存储                                |
| -------- | -------- | ----------------------------------------- | --------------------------------------- |
| 空间性能 | 存储密度 | **（?）**                                 | **（?）**                               |
| ^        | 容量分配 | **（?）**                                 | **（?）**                               |
| 时间性能 | 查找运算 | **（?）**                                 | **（?）**                               |
| ^        | 读运算   | **（?）**                                 | **（?）** 最好 **（?）**,最差 **（?）** |
| ^        | 插入运算 | **（?）** 最好 **（?）** ，最差 **（?）** | **（?）**                               |
| ^        | 删除运算 | **（?）**                                 | **（?）**                               |

* 队列与栈
  * 队列：**（?）**
  * 栈：**（?）**

## 广义表
* n各元素组成的有序序列，线性表的推广
* 递归重数、长度：**（?）**
* 取表头、 取表尾 **（?）**

## 数与二叉树（重点掌握）
### 概念
  * 节点的度、树的度、 叶子结点、分支节点、父节点、子节点、兄弟节点 各个概念 **（?）**
* 满二叉树、完全二叉树 各是 **（?）**
* 特性
  * i层上最多有 **（?）** 个结点
  * 深度为k的二叉树最多有 **（?）** 个结点
  * 对任一二叉树 **（?）** N0是叶子节点数 N2是度为2的节点数
  * 如果对一个有n个结点的完全二叉树结点按层序编号有从 **（?）** 层
* 二叉树遍历
  * 前中后 各是 **（?）**
* 反向构造二叉树
  * **（?）** 为必须的
* 树转二叉树
  * 结点如何相连 **（?）**


> 二叉排序树的查找效率取决于二叉排序树的 **（?）**，对于结点个数相同的二叉排序树，平衡二叉树的深度最小，而单枝树的深度是最大的，故效率最差。

### 查找二叉树（二叉排序树）
* 什么样 **（?）**
* 左右与根节点关系 **（?）**
* 插入：若已存在，**（?）**。若树为空，**（?）**。其他情况 **（?）**
* 删除：若为叶子结点 **（?）**。若只有一个叶子节点 **（?）**。若有两个 **（?）** 

### 哈夫曼树（最优二叉树）
* 什么样 **（?）**
* 如何构造 **（?）**
* 树的路径长度、权 各是 **（?）**
* 带权路径长度、树的带权路径长度（树的代价） 计算 **（?）**
* 根据字符频率画树 **（?）**

### 线索二叉树

### 平衡二叉树
* 什么样 **（?）**
* 定义 **（?）**
* 每个结点的平衡度只能为 **（?）**

## 图
* 无向图，有向图 **（?）**
* 完全图：在无向图中 **（?）** ，在有向图中 **（?）**
* 图的存储：
  * 邻接矩阵：有n个点就是nxn的二维表，边为1，其他为0 画图 **（?）**。无向图有对称性，可以只存上三角或下三角
  * 邻接表 **（?）**、一个数组记录所有结点，每个结点可以到哪些结点用链表连接。画图 **（?）**
* 图的遍历：
  * 深度优先：画图 **（?）**，一个结点试探到底
  * 广度优先：画图  **（?）**，先访问邻接
* 拓扑排序：画图  **（?）**，表达事件先后执行。从无箭头指向结点开始，结点的前驱结点都完成可以开始
* 图的最小生成树：画图  **（?）**，使权值加起来最小，
  * 普里姆算法：时间复杂度 **（?）**，n为定点，图稠密是性能更 **（?）**
  * 克鲁斯卡算法：时间复杂度 **（?）**，m为边
> 树没有环路，有n个结点，边最多为 **（?）**
> 无向图连接矩阵非零元素为 **（?）**，E为边
> **（?）图** 适合采用邻接矩阵来存储
> 

## 算法基础与常见算法（重要）
* 有穷性 、确定性、输入、输出、有效性 各自含义 **（?）**

## 时间复杂度与空间复杂度（重要）
* 时间复杂度 **（?）** 、 空间复杂度 **（?）**
* O(n)、$\log_2n$、$n\log_2n$、一般是 **（?）**
* **递推式** $T(n) = aT(\frac n b) + f(n)$ 时间复杂度比较 **（?）** 和f(n)中取较大

## 排序与查找（重点）

### 顺序查找
* 基本思想 **（?）**
* 平均查找时间  **（?）** ， 时间复杂度 **（?）**

### 二分查找
* 基本思想 **（?）**
* 要求：**（?）**
* 优缺：**（?）** ；缺点：**（?）** ；适用：**（?）** 
* 比较次数最多 **（?）** 次，时间复杂度为 **（?）**
* 关键字比较序列出现情况判断，**还原的查找二叉树上一个结点只会有一个子节点**
* 比较过程掌握  **（?）**  ，**注意求mid时小了左移，大了右移**

### 散列表
* 基本思想 **（?）**
* 装填因子代表 **（?）** ，越大则 **（?）**
* 构造哈希函数使应尽量使关键字的所有组成部分起作用。
* 线性探测法 **（?）**，H（Key） = Key mod p，p的值一般会取 **（?）**
* 伪随机数法 **（?）**

### 排序
* 稳定排序与不稳定排序 **（?）**
* 内排序与外排序 **（?）**
* 插入类排序、交换类排序、选择排序、归并排序、基数排序 各分类下有 **（?）**

#### 直接插入排序
* 了解过程 **（?）**
* 平均时间复杂度： **（?）** ，最坏 **（?）** ，辅助存储 **（?）** ，稳定性 **（?）**
* 在 **（?）** 情况下为最适宜排序算法
* 提示：一个一个插入时候比较

#### 希尔排序
* 了解过程 **（?）**
* 平均时间复杂度： **（?）** ，最坏 **（?）** ，辅助存储 **（?）** ，稳定性 **（?）**
* 提示：d=n/2 求增量，反复，直到步长为1

#### 直接（简单）选择排序
* 了解过程 **（?）**
* 平均时间复杂度： **（?）** ，最坏 **（?）** ，辅助存储 **（?）** ，稳定性 **（?）**
* 提示：剩余部分取出最小的一个与剩余第一个交换，反复。

#### 堆排序
* 了解过程 **（?）**
* 平均时间复杂度： **（?）** ，最坏 **（?）** ，辅助存储 **（?）** ，稳定性 **（?）**
* 小顶堆 **（?）**、大顶堆
* 提示：建堆、取出堆顶元素、重建、反复

#### 冒泡排序
* 了解过程 **（?）**
* 平均时间复杂度： **（?）** ，最坏 **（?）** ，辅助存储 **（?）** ，稳定性 **（?）**
* 提示：相邻元素比较，把较小的从底部移到顶部
* 与直接插入排序相比：每次冒泡交换多次，直接交换一次

#### 快速排序（分治法）
* 了解过程 **（?）**
* 平均时间复杂度： **（?）** ，最坏 **（?）** ，辅助存储 **（?）** ，稳定性 **（?）**
* 采用 **（?）** 算法设计思想
* 在 **（?）** 的时候算法时间复杂度是最坏的，此时为 **（?）**。相反在越 **（?）** 的时候时间复杂度越高，为 **（?）**
* 提示：选一个基准，把记录分两组比这个小的放左边，大的放右边。再在剩余分组里进行排序

#### 归并排序（合并）（分治）
* 了解过程 **（?）**
* 平均时间复杂度： **（?）** ，最坏 **（?）** ，辅助存储 **（?）** ，稳定性 **（?）**
* 提示：二路合并。将两个或两个以上的子表合并，最终合并成一个

#### 基数排序
* 了解过程 **（?）**
* 平均时间复杂度： **（?）** ，最坏 **（?）** ，辅助存储 **（?）** ，稳定性 **（?）**
* 提示：根据关键字排序

## 算法设计思想

* 分治法、动态规划法、贪心法、回溯法：思想 **（?）** 

## 其他
| 方式                 | 时间复杂度平均 | 最坏          | 辅助存储     | 稳定   |
| -------------------- | -------------- | ------------- | ------------ | ------ |
| 直接插入排序         | $O(n^2)$       | $O(n^2)$      | $O(1)$       | 稳定   |
| 希尔排序             | $O(n^{1.3})$   | $O(n^2)$      | $O(1)$       | 不稳定 |
| 直接（简单）选择排序 | $O(n^2)$       | $O(n^2)$      | $O(1)$       | 不稳定 |
| 堆排序               | $O(n\log_2n)$  | $O(n\log_2n)$ | $O(1)$       | 不稳定 |
| 冒泡排序             | $O(n^2)$       | $O(n^2)$      | $O(1)$       | 稳定   |
| 快速排序             | $O(n\log_2n)$  | $O(n^2)$      | $O(\log_2n)$ | 不稳定 |
| 归并排序             | $O(n\log_2n)$  | $O(n\log_2n)$ | $O(n)$       | 稳定   |
| 基数排序             | $O(d(r+n))$    | $O(d(r+n))$   | $O(r+n)$     | 稳定   |
