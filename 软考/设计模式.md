
| 分类   | 设计模式名称                |                | 简要说明                                                                                                                   | 速记关键字                   |
| ------ | --------------------------- | -------------- | -------------------------------------------------------------------------------------------------------------------------- | ---------------------------- |
| 创建型 | Abstract Factory            | 抽象工厂模式   | 提供一个创建一系列相关或相关依赖对象的接口,而无需指定他们具体的类                                                          | 生产**系列**对象             |
| ^      | Factory Method              | 工厂方法模式   | 定义一个创建对象的接口, 让子类决定实例化哪一个类, 工厂方法使一个类的实例化延伸到了子类                                     | 动态产生对象                 |
| ^      | Build                       | 构建器模式     | 将一个复杂类的表示与其构造相分离,使得相同的构建过程能够得出不同的表示                                                      | 复杂对象构造                 |
| ^      | Prototype                   | 原型模式       | 用原型实例指定创建对象的类型,并且通过拷贝这个原型来创建新的对象                                                            | 克隆对象                     |
| ^      | **Singleton**               | **单例模式**   | 保证一个类只有一个实例,并提供一个访问它的全局访问点                                                                        | 单实例                       |
| 结构型 | **Adapter**                 | **适配器模式** | 将一个类的接口转换成用户希望得到的另一种接口. 它使得原本不相容的接口得以协同工作                                           | **转换**接口                 |
| ^      | Bridge                      | 桥接模式       | 将类的抽象部分和它的实现部分分离开,使他们可以独立的变化                                                                    | 继承树拆分                   |
| ^      | Composite                   | 组合模式       | 将对象组合成树形结构表示"整体-部分"的层次结构,使得用户对单个对象和组合对象的使用具有一致性                                 | 树形目录结构                 |
| ^      | **Decorator**               | **装饰模式**   | 动态地给一个对象添加一些额外的职责. 它提供了子类扩展功能的一个灵活的替代,比派生一个子类更加灵活                            | **附加职责**                 |
| ^      | Facade                      | 外观模式       | 定义一个高层结构,为子系统中的一组接口提供一个一致的外观,从而简化了该子系统的使用                                           | 对外统一接口                 |
| ^      | Flyweight                   | 享元模式       | 支持大量细粒度对象共享的有效方法                                                                                           | 文章共享文字对象             |
| ^      | Proxy                       | 代理模式       | 对其他对象提供一种代理以控制这个对象的访问                                                                                 | 两者之间不直接通信           |
| 行为型 | **Chain of Reposnsibility** | **职责链模式** | 通过给多个对象处理请求的机会,减少请求的发送与接收者之间的耦合.讲接收对象链接起来,在链中传递请求,直到有一个对象处理这个请求 | 传递职责                     |
| ^      | **Command**                 | **命令模式**   | 将一个请求封装为一个对象,从而可用不同的请求对客户进行参数化,将请求排队或记录请求日志,支持可撤销操作                        | 日志记录,可撤销              |
| ^      | Interpreter                 | 解释器模式     | 给定一种语言,定义它的文法表示,并定义一个解释器.该解释器用来根据文法表示来解释语言中的句子                                  | 虚拟机的机制                 |
| ^      | Iterator                    | 迭代器模式     | 提供一种方法来顺序访问一个聚合对象中的各个元素,而不需要暴露该对象的内部表示                                                | 数据库数据集                 |
| ^      | Mediator                    | 中介者模式     | 用一个中介对象来封装一系列的对象交互.它使各对象不需要显示地互相调用,从而达到低耦合,还可以独立地改变对象间的交互            | 不直接引用                   |
| ^      | Memento                     | 备忘录模式     | 在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态,从而可以在以后讲该对象恢复到原先保存的状态        | (记录)                       |
| ^      | **Observer**                | **观察者模式** | 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖它的对象都得到通知并自动更新                           | 联动(一个被观察者多个观察者) |
| ^      | State                       | 状态模式       | 允许一个对象在其内部状态改变时改变它的行为                                                                                 | 状态改变行为                 |
| ^      | **Strategy**                | **策略模式**   | 定义一系列算法,把它们一个个封装起来,并且使它们之间可以互相替换,从而让算法可以独立于使用它的用户而变化                      | 多方案切换                   |
| ^      | Template Method             | 模板方法模式   | 定义一个操作中的算法骨架,而将一些步骤延迟到子类中,使得子类可以不改变一个算法的结构即可重新定义算法的某些步骤               | /                            |
| ^      | Visitor                     | 访问者模式     | 表示一个作用于某个对象结构中的各元素操作,使得在不改变各元素的类的前提下定义作用于这些元素的新操作                          | /                            |


