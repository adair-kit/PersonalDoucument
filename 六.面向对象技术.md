# 面向对象技术

## 面向对象的基本概念

* **对象 :** 属性(数据) + 方法(操作) + 对象ID
* **类 :** 实体类(数据),控制类(类之间协调),边界类(对外接口)
* **继承与泛化 :** 服用机制
* **封装 :** 隐藏对象的属性和实现细节,仅对外公开接口
* **多态 :** 不同对象收到**同样的信息**产生不同的结果
* **接口 :** 一种特殊的类,他只有方法定义没有实现
* **重载 :** 一个类可以有多个**同名而参数类型不同的方法**
* **模板类**
* **消息和消息通信 :** 消息是异步通信的

## 面向对象设计7大原则
* **单一职责原则 :** 设计目的单一的类
* **开放-封闭原则 :** 对扩展开放，对修改封闭
* **李氏(Liskov)替换原则 :** 子类可以替换父类
* **依赖倒置原则 :** 要依赖于抽象，而不是具体实现;针对接口编程，不要针对实现编程
* **接口隔离原则 :** 使用多个专门的接口比使用单一的总接口要好
* ~~**组合重用原则 :** 要尽量使用组合，而不是继承关系达到重用目的~~
* **迪米特(Demeter)原则(最少知识法则) :** 一个对象应当对其他对象有尽可能少的了解

## UML

|                |                    |                         |
| -------------- | ------------------ | ----------------------- |
| 结构图(静态图) | 类图               | /                       |
| ^              | 对象图             | /                       |
| ^              | 包图*              | /                       |
| ^              | 聚合结构图*        | /                       |
| ^              | 构建图             | /                       |
| ^              | **部署图**         | 软硬件之间的映射        |
| ^              | 制品图             | /                       |
| 行为图(动态图) | **用例图(争议)**   | 系统与外部参与者的交互  |
| ^              | **顺序图**         | 强调按时间顺序          |
| ^              | **通信图(协作图)** | (与上面称为交互图)      |
| ^              | 定时图*            | /                       |
| ^              | 状态图             | /                       |
| ^              | **活动图**         | 类似程序流程图,并行行为 |
| ^              | 交互概览图         | /                       |

### 类图

| 类图            |                                  |                                                                                                                                                        |                              |
| --------------- | -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------- |
| 一般关系(is-a)  | 泛化(继承)关系<br>Generalization | 特殊/一般关系                                                                                                                                          | ————▷/▶<br>指向父类      |
| ^               | 实现关系<br>Realization          | 类与接口的关系                                                                                                                                         | — — — —▷<br>指向接口     |
| 关联关系(has-a) | 关联关系<br>Association          | 一种拥有关系,它使一个类知道另一个类的属性和方法<br>双向的关联可以有两个箭头或者没有箭头,单向的关联有一个箭头.两端可以有1:n n:n<br>还有自身关联指向自己 | —————><br>指向被拥有者  |
| ^               | 聚合关系<br>Aggregation          | 是整体与部分的关系，且部分可以离开整体而单独存在(生命周期不同)。                                                                                       | —————◇<br>指向整体      |
| ^               | 组合(合成)关系<br>Composition    | 是整体与部分的关系，但部分不能离开整体而单独存在(生命周期相同)。                                                                                       | —————◆<br>指向整体      |
| 依赖关系(use-a) | 依赖关系<br>Dependency           | 一个事物发生变化会影响另一个事物<br>一种使用的关系，即一个类的实现需要另一个类的协助                                                                   | — — — —><br>指向被使用者 |


## 设计模式分类(23)

| 分类   | 设计模式名称                              | 简要说明                                                                                                                   | 速记关键字                   |
| ------ | ----------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- | ---------------------------- |
| 创建型 | Abstract Factory<br>抽象工厂模式          | 提供一个创建一系列相关或相关依赖对象的接口,而无需指定他们具体的类                                                     | 生产**系列**对象               |
| ^      | Factory Method<br>工厂方法模式            | 定义一个创建对象的接口, 让子类决定实例化哪一个类, 工厂方法使一个类的实例化延伸到了子类                                    | 动态产生对象                 |
| ^      | Build<br>构建器模式                       | 将一个复杂类的表示与其构造相分离,使得相同的构建过程能够得出不同的表示                                                      | 复杂对象构造                 |
| ^      | Prototype<br>原型模式                     | 用原型实例指定创建对象的类型,并且通过拷贝这个原型来创建新的对象                                                            | 克隆对象                     |
| ^      | **Singleton<br>单例模式**                 | 保证一个类只有一个实例,并提供一个访问它的全局访问点                                                                        | 单实例                       |
| 结构型 | **Adapter<br>适配器模式**                 | 将一个类的接口转换成用户希望得到的另一种接口. 它使得原本不相容的接口得以协同工作                                           | **转换**接口                 |
| ^      | Bridge<br>桥接模式                        | 将类的抽象部分和它的实现部分分离开,使他们可以独立的变化                                                                    | 继承树拆分                   |
| ^      | Composite<br>组合模式                     | 将对象组合成树形结构表示"整体-部分"的层次结构,使得用户对单个对象和组合对象的使用具有一致性                                 | 树形目录结构                 |
| ^      | **Decorator<br>装饰模式**                 | 动态地给一个对象添加一些额外的职责. 它提供了子类扩展功能的一个灵活的替代,比派生一个子类更加灵活                            | **附加职责**                 |
| ^      | Facade<br>外观模式                        | 定义一个高层结构,为子系统中的一组接口提供一个一致的外观,从而简化了该子系统的使用                                           | 对外统一接口                 |
| ^      | Flyweight<br>享元模式                     | 支持大量细粒度对象共享的有效方法                                                                                           | 文章共享文字对象             |
| ^      | Proxy<br>代理模式                         | 对其他对象提供一种代理以控制这个对象的访问                                                                                 | 两者之间不直接通信           |
| 行为型 | **Chain of Reposnsibility<br>职责链模式** | 通过给多个对象处理请求的机会,减少请求的发送与接收者之间的耦合.讲接收对象链接起来,在链中传递请求,直到有一个对象处理这个请求 | 传递职责                     |
| ^      | **Command<br>命令模式**                   | 将一个请求封装为一个对象,从而可用不同的请求对客户进行参数化,将请求排队或记录请求日志,支持可撤销操作                        | 日志记录,可撤销              |
| ^      | Interpreter<br>解释器模式                 | 给定一种语言,定义它的文法表示,并定义一个解释器.该解释器用来根据文法表示来解释语言中的句子                                  | 虚拟机的机制                 |
| ^      | Iterator<br>迭代器模式                    | 提供一种方法来顺序访问一个聚合对象中的各个元素,而不需要暴露该对象的内部表示                                                | 数据库数据集                 |
| ^      | Mediator<br>中介者模式                    | 用一个中介对象来封装一系列的对象交互.它使各对象不需要显示地互相调用,从而达到低耦合,还可以独立地改变对象间的交互            | 不直接引用                   |
| ^      | Memento<br>备忘录模式                     | 在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态,从而可以在以后讲该对象恢复到原先保存的状态        | (记录)                       |
| ^      | **Observer<br>观察者模式**                | 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖它的对象都得到通知并自动更新                           | 联动(一个被观察者多个观察者) |
| ^      | State<br>状态模式                         | 允许一个对象在其内部状态改变时改变它的行为                                                                                 | 状态改变行为                 |
| ^      | **Strategy<br>策略模式**                  | 定义一系列算法,把它们一个个封装起来,并且使它们之间可以互相替换,从而让算法可以独立于使用它的用户而变化                      | 多方案切换                   |
| ^      | Template Method<br>模板方法模式           | 定义一个操作中的算法骨架,而将一些步骤延迟到子类中,使得子类可以不改变一个算法的结构即可重新定义算法的某些步骤               | /                            |
| ^      | Visitor<br>访问者模式                     | 表示一个作用于某个对象结构中的各元素操作,使得在不改变各元素的类的前提下定义作用于这些元素的新操作                          | /                            |



## 其他
1. **对象**是封装数据和行为的整体
2. 选择面向对象语言开发软件时,不需要着重考虑的因素是**是否支持全局变量和全局函数定义**
3. 面向对象分析侧重于理解问题
4. 面向对象设计侧重于理解解决方案
5. 面向对象分析描述软件要做什么
6. 对象对象设计关注技术和实现层面的细节
7. **实体类**是应用领域中的核心类们一般用于保存系统中的信息以及提供针对这些信息的相关处理行为
8. **边界类**是系统内对象和系统外参与者的联系媒介
9. **控制类**主要协调上述两种类对象之间的交互


